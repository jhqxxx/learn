<!--
 * @Author: jhq
 * @Date: 2023-02-03 23:28:53
 * @LastEditTime: 2025-01-17 13:08:02
 * @Description: 
-->
#### 输入输出流
    * iostream库中，std名字空间下，cin/cout对象

* 名字空间vs库（头文件）
    名字空间是逻辑概念，类似于贴标签：一个名字空间是一种标签
    库是物理概念，类似于工具箱：一个库含有多个同类工具
    名字空间为了区别不同工具箱里的同名工具，避免同名歧义
    库为了将不同用途的工具分别装在不同的箱子里，实现解耦


双冒号即可以指定类，也可以指定变量和命名空间

using关键字

string是C++封装的字符串类
自增++/自减--运算符：将变量自身加1/减1
    * 前自增/减：先自增/自减，后执行表达式
    * 后自增/减：先执行表达式，后自增自减

bool类型：取值为true或false，本质是单字节无符号整数0或1

函数目的：将重复发生的流程统一起来，实现代码复用和解耦

函数默认参数：必须在函数声明中设置默认参数！默认参数必须在形参列表的结尾！

函数引用传参：引用->别名
    特指左值引用，即给一个已经有名字的变量起别名，不可存在空引用
    int &->整型引用
    思考：
        指针传参解决了什么问题？
            当参数值很大时，避免按值传参发生的拷贝，实现原地改动调用方传入参数的功能。
        指针传参还有什么问题：
            代码中夹杂着间接引用符合‘*’难写难看难读，还有符号优先级的问题！
        这个问题如何解决：
            如果形参就是实参的一个别名，即可解决

函数重载 overload：
    允许多个同名函数存在，分别处理不同类型/数量的参数
    多个函数的名字相同，参数列表（数量、类型）不同
    减少了函数调用方的代码冗余
    存在问题：匹配是编译器自动完成的，调用代码可能有歧义
    不允许仅有返回值不同的函数重载：重载是针对参数列表的
    overload和返回值无关，需要满足：
        声明时：1.名字相同，2.参数列表不同
        调用时：3.不产生匹配歧义

内联函数：
    如果某个函数的功能非常简单，又被反复调用的话，因为函数调用这个行为本身也是有一定开销的，那么这个函数的"额外开销"占比就很大。
    建议编译器在编译时将函数直接在调用处展开，避免函数调用行为的额外开销，即函数内联；
    inline只是建议：并不是写了inline关键字就一定为被内联，只是提出建议，由编译器决定是否采纳。
    内联发生在编译时，提升运行时的效率

面向对象：
    抽象: 识别系统中的实体， 提炼属性/行为
    封装：将类的一些成员变量或方法藏起来，不允许外界直接操作
        对于getter，加const修饰，避免对参数进行修改
        getter函数通常会被设置为const函数，setter函数则通常接受const参数
        int get_n() const{return n;}
        void set_n(const int n) { this->n = n;}
    继承：同一对象可能有多重身份，且这些身份有递进层级关系，实现代码复用        
        public: 共有继承
        protected: 保护继承
        private: 私有继承
        继承方式：决定父类成员在子类中的访问控制属性
            * 父类的private成员不会被子类继承
        父子同名成员并存：
            直接使用默认指子类成员
            son.func();
            con.Father::func()
        实践中会有这类情况：
            父类中的某些行为需要在子类中被更加具体的细化
            父类中的某些行为不可确定，必须在子类中实现
            virtual 虚函数：父类的虚函数可以在子类中被重写，但参数和返回值必须保持一致
            含有虚函数的类时虚类
        
        纯虚函数和抽象类：
            纯虚函数：不实现，仅声明为纯虚函数，子类里重写定义 virtual 加 = 0将函数声明为纯虚函数
            含有纯虚函数的类叫抽象类，仅有纯虚函数的类叫接口
            抽象类和接口不可实例化
    多态：一个对象就是内存中的一个实体，它只能属于一个确定的类：最精确的子类
        虚函数重写 + 指针：指向子类对象的父类指针， 可以把不同子类统一视为其共同父类
        于是无需针对不同的子类写相同逻辑，统一视作其共同父类，利用指针操作即可
        本质是虚函数将能做什么和怎么做分离，父类指定要做什么，子类来实现具体做法。
        静态联编与动态联编：
            上述利用虚函数重写+指针实现的多态特指运行时多态，与之相对的是编译时多态 
            静态联编 = 编译时多态 = 函数重载 = overload
            动态联编 = 运行时多态 = 虚函数重写 = override
        联编(bind):确定具体要调用多个同名函数中的哪一个
        静态联编：在编译时就确定了要调用的是哪个函数（根据多个重载函数的参数列表确定）
        动态联编：直到运行时才知道实际调用的时哪个函数（根据指针指向对象的实际身份）

        

    特殊的成员函数：构造函数和析构函数
        构造：对象实例化时，在分配得到的空间上构造对象（如初始化成员变量，分配资源等）
            1. 创建对象时自动调用
            2. 可以有多个重载
            3. 不可以有返回值
            默认构造函数（无参构造函数）：没有参数的构造函数
            有参构造函数：有参数的构造函数
        析构：对象生命周期结束时，回收空间前，完成对象的清理工作（如释放资源等）
        构造函数和析构函数都没有返回值！
        析构函数没有参数
    this指针：在类定义内部使用，指向当前对象

深拷贝与浅拷贝：
    浅拷贝：只简单复制成员变量的值
    深拷贝：对于外部资源也复制一份
    拷贝构造函数：拷贝已存在同类对象来构造新对象，因此参数时该类的引用

运算符重载：
    为自定义的类重载一个运算符函数，其第一个操作数是对象本身，其他操作数是该函数参数

类的模块化编程

类的静态成员：static
    隶属于类，不属于任何一个对象，生命周期贯穿整个程序
    类内可直接访问，外部则需要通过类名：：变量名

构造析构顺序：
    构造函数的调用顺序：父 -> 子    
    析构函数的调用顺序：子 -> 父
    假设A<-b<-c，则实例化一个c类对象需要依次 调用A、B、C的构造函数，析构：C、B、A的顺序

多继承：
    C++运行多继承：一个子类可以继承自多个父类
    在多继承时有可能出现父类成员多个副本问题：多个父类可能有共同父类
    虚继承可解决？？？

友元函数：friend
    通过friend关键字在类内进行声明，但并不是类的成员函数
    类的友元函数可以直接访问该类的private和protected成员

虚函数表：
    每个对象存有一张虚函数表，记录了其所有虚函数指针
    当子类重写父类的虚函数时，用子类重写的版本覆盖父类原有的虚函数指针
    

构造函数参数列表：
    构造函数参数列表其实就是一系列构造函数的调用，使他们在本对象构造前构造好
    没有默认构造函数的类成员数据或父类必须放在参数列表里构造

UML类图：public属性的前面是+号，private前面是-号

结构体vs类：
    简单理解：结构体+行为(成员函数) = 类
    事实上C++中也支持结构体定义成员方法，两者并无本质区别了
    根据使用场景选择结构体或类：
        结构体：主要记录数据，极少行为(如资源配置信息，网络连接信息等)
        类：即有属性也有行为(如学生类、用户类、玩家类等)


类动态内存分配：
    C++内存区域：
        堆栈：变量、对象、调用函数等所需要的空间由编译器管理，来一个就生成一个压入栈中，结束一个就弹出一个。
        堆：由程序员自己编写代码管理：申请、使用、释放->动态内存分配，编译器不维护。
        全局变量
        只读代码数据
    C：malloc/free是一对函数,如果不释放内存空间->内存泄漏->导致内存不够->内存溢出
    C++:new/delete是一对运算符,申请所需大小的内存->构造对象->返回指针供使用->析构对象->释放空间
        new[]:申请空间并批量构造对象数组，返回首元素指针
        delete[]: 批量析构对象数组并释放空间，只能用于new[]出来的指针

虚析构函数：
    内存泄漏vs内存溢出
        内存泄漏（用了不释放）：导致内存溢出（资源不够）的可能性增大
    虚析构函数时为了避免子类资源泄漏（如内存泄漏或文件句柄不释放）
    将父类的析构函数设置为虚函数

野指针：不知道指向什么地址的指针
垂悬指针：指向的地址已经被回收/清理了
空指针：nullptr关键字，表示“没有地址”的含义

异常处理：
    try-throw-catch:
    try{
        //被保护的代码段
        throw(异常对象)；
    }
    catch(期望捕获类型 变量名){
        //处理异常的代码段
    }
    //catch处理完从这里继续
    catch(...):能捕获一切异常，它后面的其他catch块等于没写，因此catch(...)应放在多个catch块的最后一个

函数异常限定符：显式地指明是否允许函数抛出异常
    void func1() throw();  ->什么都不允许抛出
    void func1() throw(int, double); -> 允许抛出int或double
    void func3() throw(...); -> 允许抛出任何东西，不写默认是什么都可以抛出

模板与泛型：
    模板编程：类型参数化，将类型信息也视作一个普通参数，使代码逻辑与类型信息分离 -> 泛型思想
    template关键字：表明接下来定义一个模板
    typename关键字:表明该模板参数是一个类型名
    模板参数可以用在参数或返回值上
    模板类：把模板参数用在类定义上，即模板参数的作用范围为该类内部

文件IO:
    读文件用ifstream对象，写文件用ofstream对象
    std::fstream->可以同时指定多个打开方式，用按位或|连接
    ios::in->以输入模式打开已存在文件，不存在会报错
    ios::out->以输出模式打开文件，不存在则新建，存在则清空
    ios::app->以追加模式打开文件，不存在则新建，存在从尾部追写
    ios::binary->以二进制模式打开文件，不用此标记则默认以文本模式打开

二进制文件：
    将数据在内存中的实际存储内容直接写入到文件中，读取时需要知道存储和理解的格式

输出格式控制：
    控制输出数据的宽度：setw(n)
    控制输出浮点数的精度：setprecision(n)
    控制输出整数的进制：setbase(n)
    控制左对齐右对齐：setiosflags(ios::left)/setiosflags(ios::right)

#define:宏定义，本质上是文字替换
    #define MUL(x, y) x*y
    int n=2, m = MUL(n+3, n+4);
    替换后为 n+3 * n+4,所以m=12
const int SIZE = 10;->不变量，不能在赋值号左边被赋值，但通过指针可以改变它的值

2025/01/02
###### 构造函数成员初始化列表
* 常量只能初始化，不能赋值，对于const数据成员，必须在执行到构造函数体之前，即创建对象时进行初始化。通常，初值可以是常量或构造函数的参数列表中的参数，这种方法并不限于初始化常量。
* 对于const类成员和被声明为引用的类成员，都必须使用这种语法
* 只能用于构造函数
